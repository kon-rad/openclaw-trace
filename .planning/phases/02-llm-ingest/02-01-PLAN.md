---
phase: 02-llm-ingest
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/ingest/types.go
  - internal/ingest/worker.go
  - internal/ingest/truncate.go
  - internal/db/insert.go
  - internal/app/runtime.go
  - internal/ingest/worker_test.go
autonomous: true
requirements:
  - STOR-03
  - STOR-04
  - LLMT-03
  - LLMT-04
must_haves:
  truths:
    - "A single persist worker owns all SQLite writes for ingest events."
    - "Worker writes batched transactions (50 max or 500ms)."
    - "Stored trace/error rows have generated UUID trace_id values."
    - "Input/output text is truncated to OCT_MAX_TEXT_BYTES before persistence."
  artifacts:
    - path: "internal/ingest/worker.go"
      provides: "single-writer ingest loop and batch flush policy"
    - path: "internal/db/insert.go"
      provides: "trace and error insert SQL operations"
    - path: "internal/ingest/truncate.go"
      provides: "byte-safe truncation helper"
  key_links:
    - from: "internal/app/runtime.go"
      to: "internal/ingest/worker.go"
      via: "runtime startup and shutdown wiring"
      pattern: "Start|Run|Stop"
    - from: "internal/ingest/worker.go"
      to: "internal/db/insert.go"
      via: "batch transaction insert path"
      pattern: "InsertTrace|InsertError"
---

<objective>
Create the ingest persistence core used by Phase 2 endpoints: buffered channel, single writer worker, batch transactions, UUID trace IDs, and truncation guardrails.

Purpose: Ensure fire-and-forget handlers can enqueue safely while persistence remains consistent and low-overhead.
Output: Runtime-integrated ingest worker with tests for batching, truncation, and non-blocking queue semantics.
</objective>

<execution_context>
@/Users/konradgnat/.claude/get-shit-done/workflows/execute-plan.md
@/Users/konradgnat/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@.planning/phases/02-llm-ingest/02-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ingest event model and runtime queue wiring</name>
  <files>internal/ingest/types.go, internal/app/runtime.go</files>
  <action>Define internal ingest envelope and payload types for trace and error events. Add runtime-owned buffered channel (`cap=512`) plus counters to support enqueue/drop tracking. Start and stop a single persist worker from runtime lifecycle so shutdown waits for worker drain behavior.</action>
  <verify>`go test ./...` passes and runtime compiles with ingest channel + worker wiring without introducing additional SQLite writers.</verify>
  <done>There is exactly one ingest worker write path and queue capacity is fixed to 512.</done>
</task>

<task type="auto">
  <name>Task 2: Implement single-writer batched persistence with UUID + truncation</name>
  <files>internal/ingest/worker.go, internal/ingest/truncate.go, internal/db/insert.go</files>
  <action>Implement worker loop that consumes ingest events and flushes to SQLite with policy: max 50 events or 500ms timer window. Generate UUID v4 trace_id for each persisted row. Apply OCT_MAX_TEXT_BYTES truncation for trace input/output text before insert. Keep inserts transactional and owned only by this worker.</action>
  <verify>Add and run tests validating UUID generation, truncation byte limit, and batch flush timing behavior (`go test ./internal/ingest -v`).</verify>
  <done>STOR-03/STOR-04/LLMT-03/LLMT-04 behavior is implemented and test-covered.</done>
</task>

<task type="auto">
  <name>Task 3: Add worker-level reliability tests</name>
  <files>internal/ingest/worker_test.go</files>
  <action>Create focused tests for queue saturation drop accounting, batched persistence visibility within 600ms, and worker stability under burst load. Use temp SQLite DB and runtime-compatible config values for deterministic assertions.</action>
  <verify>`go test ./internal/ingest -run Test -v` passes and demonstrates no panic/blocking during burst enqueue scenarios.</verify>
  <done>Core ingest persistence behavior is validated and ready for HTTP handler integration in Plan 02.</done>
</task>

</tasks>

<verification>
- Worker is the only writer and runs with queue cap 512.
- Batch flush follows 50 events / 500ms policy.
- UUID and text truncation logic are enforced in persisted data.
</verification>

<success_criteria>
- [ ] STOR-03 implemented with single writer goroutine.
- [ ] STOR-04 implemented with 50/500ms batch flush policy.
- [ ] LLMT-03 implemented with unique generated trace_id.
- [ ] LLMT-04 implemented with OCT_MAX_TEXT_BYTES truncation.
</success_criteria>

<output>
After completion, create `.planning/phases/02-llm-ingest/02-01-SUMMARY.md`
</output>
