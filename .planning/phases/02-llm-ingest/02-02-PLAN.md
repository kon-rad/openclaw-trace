---
phase: 02-llm-ingest
plan: 02
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - internal/server/ingest_handlers.go
  - internal/server/server.go
  - internal/server/ingest_handlers_test.go
  - internal/app/runtime.go
  - internal/db/query_test.go
autonomous: true
requirements:
  - LLMT-01
  - LLMT-02
  - LLMT-05
  - ERRC-01
  - ERRC-02
  - ERRC-03
  - ERRC-04
  - ERRC-05
must_haves:
  truths:
    - "POST /v1/traces accepts valid payloads and returns 202 quickly."
    - "POST /v1/errors accepts valid payloads and returns 202 quickly."
    - "Handlers never block on DB writes; they enqueue or drop."
    - "Trace and error event fields required by roadmap are captured in storage."
  artifacts:
    - path: "internal/server/ingest_handlers.go"
      provides: "trace and error HTTP handlers with enqueue/drop semantics"
    - path: "internal/server/server.go"
      provides: "route registration for /v1/traces and /v1/errors"
    - path: "internal/server/ingest_handlers_test.go"
      provides: "endpoint behavior and saturation tests"
  key_links:
    - from: "internal/server/ingest_handlers.go"
      to: "internal/ingest/worker.go"
      via: "non-blocking channel send"
      pattern: "select.*default"
    - from: "internal/server/server.go"
      to: "internal/server/ingest_handlers.go"
      via: "POST route binding"
      pattern: "POST /v1/traces|POST /v1/errors"
---

<objective>
Expose HTTP ingest APIs over the Plan 01 worker core, guaranteeing fire-and-forget `202` behavior and complete field capture for trace + error events.

Purpose: Make OpenClaw gateway able to submit observability events without latency coupling to SQLite.
Output: Production-ready ingest endpoints with route tests and burst-load safety coverage.
</objective>

<execution_context>
@/Users/konradgnat/.claude/get-shit-done/workflows/execute-plan.md
@/Users/konradgnat/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-llm-ingest/02-CONTEXT.md
@.planning/phases/02-llm-ingest/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add POST ingest handlers for traces and errors</name>
  <files>internal/server/ingest_handlers.go, internal/server/server.go, internal/app/runtime.go</files>
  <action>Implement `POST /v1/traces` and `POST /v1/errors` handlers with JSON decoding/validation for required fields in roadmap. Handlers enqueue a normalized ingest event and always return `202` when accepted or dropped due full queue. Keep responses lightweight and non-blocking; no handler path may call SQLite directly.</action>
  <verify>Use `httptest` to confirm valid payloads return 202 and malformed payloads return 400 without panics.</verify>
  <done>LLMT-01 and ERRC-01 are implemented with fire-and-forget route behavior and runtime integration.</done>
</task>

<task type="auto">
  <name>Task 2: Ensure required capture fields are persisted end-to-end</name>
  <files>internal/server/ingest_handlers_test.go, internal/db/query_test.go</files>
  <action>Add tests that post representative trace/error payloads and assert persisted rows contain required capture fields (provider/model/text/token/cost/latency/status/error_type for traces and type/message/stack/severity/metadata for errors). Include examples for llm_error/crash/system_error classifications.</action>
  <verify>`go test ./... -run Ingest -v` passes and validates field round-trip into SQLite rows.</verify>
  <done>LLMT-02 and ERRC-02..05 are validated with realistic persistence assertions.</done>
</task>

<task type="auto">
  <name>Task 3: Add saturation and fire-and-forget performance assertions</name>
  <files>internal/server/ingest_handlers_test.go</files>
  <action>Add burst tests sending >=600 events rapidly to enforce cap behavior: first queue window accepted, overflow dropped with counter increments, process remains stable. Add timing assertion that normal loopback POST processing is immediate and does not wait for persistence window.</action>
  <verify>Run focused burst test (`go test ./internal/server -run Saturation -v`) and ensure no deadlock/panic with expected drop counter growth.</verify>
  <done>LLMT-05 non-blocking semantics are enforced and regression-protected.</done>
</task>

</tasks>

<verification>
- `/v1/traces` and `/v1/errors` return `202` fire-and-forget on valid inputs.
- Required fields are persisted and queryable.
- Burst load saturates safely with drops, never blocking handlers.
</verification>

<success_criteria>
- [ ] LLMT-01, LLMT-02, LLMT-05 implemented and tested.
- [ ] ERRC-01 through ERRC-05 implemented and tested.
- [ ] Runtime remains stable under queue saturation scenario.
</success_criteria>

<output>
After completion, create `.planning/phases/02-llm-ingest/02-02-SUMMARY.md`
</output>
